---
layout: post
title: "C# 7.2 enhancement of value types"
excerpt: "A quick guide to new features intoduced to C# in minor versions 7.1 to 7.3"
date: 2018-12-11
tags: [csharp, dotnet, code, programming]
categories: articles
comments: true
share: true
published: false
---

> C# 7.2 is another point release that adds a number of useful features. One theme for this release is working more efficiently with value types by avoiding unnecessary copies or allocations. - [docs](https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-7-2)

## Struct

What is a `struct` in .NET?

Similar to `class`, a `struct` is a compound data type that can have multiple data pieces (properties) and behaviors (methods, events, indexers etc.). A struct is a `value type`, means it is passed around as a complete value and assigning it to a new variable makes a complete new copy of the data (unlike class which is a reference type, and are passed around as references. Copying a class instance just creates a new reference to the same memory address).

Generally struct objects are stored as a single chunk of memory in the stack (not always, e.g. when they are used as property of a class object).

Class & struct can both have methods, properties, indexers & events. They both can implement interface (though casting a struct to interface type boxes it to a reference). But, there are some differences

1. Classes can inherit from another class, struct cannot inherit
2. Struct cannot have explicit (defined in code) parameter-less constructor
3. Struct cannot have a destructor
4. Struct has default implementation of `Equals()` that matches by value equality of data/properties

```cs
public interface IAnimal
{
    string MakeNoise();
}
public class DogFamily
{
    public virtual string MakeNoise() => "Aaooo";
}

//class can implement interface & inherit class but NOT struct
public class Huski : DogFamily, IAnimal //Polygon
{
    public Huski() //constructor
    { }

    ~Huski() //destructor
    { }
}

public struct Polygon
{
    //struct cannot have explicit parameterless constructor
    public Polygon(int sides)
    {
        Sides = sides;
    }

    //can have properties, methods, events & indexers
    public int Sides { get; set; }

    //ONLY classes can have destructors
    //~Polygon() { }
}

//struct can only implement interface, CANNOT inherit class or struct
public struct Rectangle : IAnimal //Polygon
{
    public int Height { get; set; }
    public int Width { get; set; }

    //this is bad example, do not do in real code (impractical & breaks LSP)
    public string MakeNoise() => throw new System.NotImplementedException();
}
```

So, **when should you use struct?**

In .NET, generally classes are preferred. If you are not sure, go with a class.

But struct can have some benefits (e.g. performance & memory overhead) in some scenarios, as allocating and deallocating small piece of memory and garbage collector may be heavier for classes than using structs. Another scenario, e.g. creating a 10 item array with reference type creates 11 references, for the 10 items and one for the array. When the same is created for struct, only a single reference is created for the array which holds the whole chunk of data with 10 structs. But having heavy structs can choke the stack memory, and passing around them as parameters can be expensive as that copies the whole data every time.

Structs are specifically useful when there are **large number of short lived, small piece of data that follows value semantics**, i.e. data that actually represents a single value (e.g. a decimal number or a coordinate point), rather than a complex object (e.g. a person with height, weight, age, name, gender, job, address etc.) - are said to follow value semantics. Another important point is, value type should equate when their values are same and need not have same reference. (`string` is an exception where is is a reference type but equality matches by value!)

An array of struct takes up one contiguous memory block with a single reference, making it more performant (not while passing around though). Also, a large value array _will generally_ grow on [LOH memory](https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/large-object-heap) sparing the GC compaction, thus further improving performance. So, that makes a good case for structs. There are some rough rules for when to consider struct over class:

1. It logically represents a single value, similar to primitive types (e.g. a decimal number or a coordinate point)
2. It has an instance size smaller than 16 bytes (small, packing a few value type data)
3. It is immutable (well, depends on actual implementation)
4. It will not have to be boxed frequently (not casted frequently, e.g. to an interface)

**Note:** Value types can be passed **by-value** or **by-reference** (to a method). **[1]** When passing by-value, a copy of data is made and passed to the parameter. **[2]** When passed by reference, no copy is made and a reference to the data is passed, so any change inside the called methd reflects in the original data.
{: .notice--info}

So we have 2 options to pass a value type, let's look at the **drawbacks** of both

1. By-value: The actual data is copied, so can be expensive
2. By-reference: Not copied, but now the data is open to modification even if unintentional

#### `In` modifier on parameter

We already have `ref` and `out` modifiers on parameters, `C# 7.2` introduces `in`.

It means that a parameter is passed by reference but cannot be modified by the calling method. This is more useful for readability of code specifying the intent that it is used as `in`put parameter only, not to be modified. Note that the variable **must be initialized** before calling the method, with that variable as parameter.

```cs
//intended use of in modifier
public double GetSquare(in double value) => value * value;
//following code does not compile, as it tries to set value of in-parameter
public double GetQube(in double value)
{
    value = 5; //error: in double variable is readonly
    return value * value * value;
}
```

**Important:** **[1]**An argument that is passed to a `ref` or `in` parameter must be initialized before it is passed. This differs from `out` parameters, whose arguments do not have to be explicitly initialized before they are passed. They can also be defined inline. **[2]** Members of a class can't have signatures that differ only by `ref`, `in`, or `out`. BUT, methos can be overloaded by using `ref`, `in`, or `out` when the other one has a simple value type parameter. **[3]** `async` methods can NOT have `ref`, `in`, or `out` parameters. Same with iterator methods with `yield`. **[4]** When reference types are passed by-reference as parameter, the called method can completely replace the object by pointing the reference to a new location (assigning a `new` object). So now, the original variable in calling method will have a new object. This is not possible when reference type is passed by-value, only individual items can be updated in-place. If a new object is assigned to pass-by-value reference parameter inside called method, further changes to that object does not reflect in original object passed!
{: .notice--info}

```cs
class ExampleClass
{
    public void M(int x) { }
    //This works (any ONE of following three)
    public void M(ref int x) { }
    //But the following 2 does NOT compile
    //public void M(in int x) { }
    //public void M(out int x) => x = 10;

    //following methods do not work if parameter has ref or other modifiers
    public IEnumerable<int> GetItems(int x)
    {
        for (int i = 0; i < x; i++)
            yield return i;
    }
    public async Task<int> GetValAsync(int x)
    {
        await Task.Delay(100);
        return x * 2;
    }
}
```

#### `Ref readonly` modifier on parameter

## References

* [What's new in C# 7.2](https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-7-2)
* [Write safe and efficient C# code](https://docs.microsoft.com/en-us/dotnet/csharp/write-safe-efficient-code)
* [ref (C# Reference)](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/ref)
* [The ‘in’-modifier and the readonly structs in C#](https://blogs.msdn.microsoft.com/seteplia/2018/03/07/the-in-modifier-and-the-readonly-structs-in-c/)
* StackOverflow threads - [1](https://stackoverflow.com/questions/13049/whats-the-difference-between-struct-and-class-in-net) , [2](https://stackoverflow.com/questions/14147340/immutable-class-vs-struct), [3](https://stackoverflow.com/questions/7484735/c-struct-vs-class-faster), [4](https://stackoverflow.com/questions/1951186/which-is-best-for-data-store-struct-classes), [5](https://stackoverflow.com/questions/521298/when-to-use-struct)
* [Readonly reference docs](https://github.com/dotnet/csharplang/blob/master/proposals/csharp-7.2/readonly-ref.md)
* [Passing Parameters](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/passing-parameters)